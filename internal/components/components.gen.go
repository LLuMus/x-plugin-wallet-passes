// Package components provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package components

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// CreatePassbookRequest Standard passes have up to 3 header, 1 primary, 4 secondary, and 4 auxiliary fields. Boarding passes 2 more primary and 5 auxiliary. Coupons and store cards can have 4 secondary and ancillary fields. Text length affects field visibility; excess text may hide fields.
type CreatePassbookRequest struct {
	// BackgroundColor The background color, used for the background of the front and back of the pass. If you provide a background image, any background color is ignored. The key for the background color is backgroundColor.
	BackgroundColor string `json:"backgroundColor"`

	// Barcode To add a barcode to a pass, provide a value for the barcodes key at the top level of the pass.json file. The value is an array of dictionaries that describes the barcode you want to display. This allows you to specify fallbacks for your barcode. PassKit displays the first supported barcode in this array. Note that the PKBarcodeFormatQR, PKBarcodeFormatPDF417, PKBarcodeFormatAztec, and PKBarcodeFormatCode128 formats are all valid on iOS 9 and later; therefore, they do not need fallbacks. watchOS does not support the PKBarcodeFormatCode128 format. If a PKBarcodeFormatCode128 barcode is included in the barcodes array, an alternative barcode is used as fallback; if a PKBarcodeFormatCode128 barcode is the only barcode you supply, no barcode is displayed.
	Barcode *struct {
		Format          *string `json:"format,omitempty"`
		Message         *string `json:"message,omitempty"`
		MessageEncoding *string `json:"messageEncoding,omitempty"`
	} `json:"barcode,omitempty"`

	// Description The description lets VoiceOver make your pass accessible to blind and low-vision users. The value for the description key in the pass specifies the description. The description should start with a high-level term such as “Membership card,” “Weekly coupon,” or “Bus ticket” followed by one or two small pieces of information, such as the coupon’s offer and the store where it’s valid. Don’t try to summarize the entire contents of the pass, but include enough detail to let users distinguish between passes of the same type.
	Description string `json:"description"`
	Fields      struct {
		// AuxiliaryFields Auxiliary fields are even less prominent than secondary fields. Appears under the secondary fields.
		AuxiliaryFields *[]Field `json:"auxiliaryFields,omitempty"`

		// BackFields The text of the back fields is run through data detectors for URLs and phone numbers, which appear as live links. Users can tap the URL to launch it in Safari and can tap phone numbers to dial them.
		BackFields *[]Field `json:"backFields,omitempty"`

		// HeaderFields The one header field that can be passed, appears at the top, next to the logo text in the front of the pass.
		HeaderFields *[]Field `json:"headerFields,omitempty"`

		// PrimaryFields The primary fields contain the most important information and are shown prominently on the front of the pass, bellow the logo, logo text and header field header. Boarding passes primary fields are normally the boarding departure and arrival airports.
		PrimaryFields []Field `json:"primaryFields"`

		// SecondaryFields Secondary fields are less important and less prominent. Appears under the primary fields.
		SecondaryFields *[]Field `json:"secondaryFields,omitempty"`
	} `json:"fields"`

	// ForegroundColor The foreground color, used for the values of fields shown on the front of the pass. The key for the foreground color is foregroundColor.
	ForegroundColor string `json:"foregroundColor"`

	// IconImage The icon (icon.png) is displayed when a pass is shown on the lock screen and by apps such as Mail when showing a pass attached to an email. The icon should measure 29 x 29 points.
	IconImage string `json:"iconImage"`

	// LabelColor The label color, used for the labels of fields shown on the front of the pass. The key for the label color is labelColor.
	LabelColor string `json:"labelColor"`

	// LogoImage The URL of the logo image is displayed in the top left corner of the pass, next to the logo text. The allotted space is 160 x 50 points; in most cases it should be narrower.
	LogoImage *string `json:"logoImage,omitempty"`

	// LogoText Displayed next to the logo image, can overflow the bounds if string is too long. This is a very important place visually. Choose something short that describes the pass, such as the company or program name.
	LogoText *string `json:"logoText,omitempty"`

	// OrganizationName The organization name is displayed on the lock screen when your pass is relevant and by apps such as Mail which act as a conduit for passes. The value for the organizationName key in the pass specifies the organization name. Choose a name that users recognize and associate with your organization or company.
	OrganizationName string `json:"organizationName"`

	// StripImage Valid for all types except "boardingPass". The strip image (strip.png) is displayed behind the primary fields. For event ticket if you specify a strip image, do not specify a background image or a thumbnail.
	StripImage *string `json:"stripImage,omitempty"`

	// ThumbnailImage Only valid for "generic" and "eventTicket" type passes. The thumbnail image (thumbnail.png) displayed next to the fields on the front of the pass. The allotted space is 90 x 90 points. The aspect ratio should be in the range of 2:3 to 3:2, otherwise the image is cropped.
	ThumbnailImage *string `json:"thumbnailImage,omitempty"`

	// Type The type of pass. The value must be one of the following values:
	// - boardingPass
	// - coupon
	// - eventTicket
	// - generic
	// - storeCard
	Type string `json:"type"`
}

// CreatePassbookResponse defines model for CreatePassbookResponse.
type CreatePassbookResponse struct {
	// Link A link for the passbook file to add to your Wallet app.
	Link *string `json:"link,omitempty"`
}

// Field defines model for Field.
type Field struct {
	// DateStyle There are three kinds of formatting you can apply to a field: alignment, date formatters, and number formatters: To set the alignment for a field, specify a value for the alignment key in the field dictionary. To format a date, specify a value for the dateStyle and timeStyle keys in the field dictionary. To format a currency amount or other number, specify a value for the currencyCode or numberStyle key in the field dictionary. Letting Wallet handle dates, times, and currency amounts ensures the right display formatting based on the user’s locale. Listing 4-3 shows an example of date and number formatting.
	DateStyle *string `json:"dateStyle,omitempty"`

	// Key (Required) A UNIQUE key that identifies a field in the pass; for example 'issued-at', 'departure-gate', 'age'.
	Key *string `json:"key,omitempty"`

	// Label The information shown on a pass is broken up into fields. Each field is defined by a dictionary, which gives it a value and label (which are displayed to the user), a unique key, and optional information about how its value should be formatted. Listing 4-2 shows a pass with a few simple fields. The primary fields contain the most important information and are shown prominently on the pass. Secondary fields are less important and less prominent, and auxiliary fields are even less so. Header fields contain highly salient information, and they are the only field that is visible when the passes are stacked up in Wallet, so use them sparingly.
	Label string `json:"label"`

	// Value The text of the back fields is run through data detectors for URLs and phone numbers, which appear as live links. Users can tap the URL to launch it in Safari and can tap phone numbers to dial them. Text on the back of the card can include line breaks, escaped in the JSON file as \n.
	Value string `json:"value"`
}

// CreatePassbookJSONRequestBody defines body for CreatePassbook for application/json ContentType.
type CreatePassbookJSONRequestBody = CreatePassbookRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create a iOS Wallet Pass (Passbook) and returns a link to visit and add it on your iOS device (iPhone, iPad, iWatch).
	// (POST /api/v1/passbook)
	CreatePassbook(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreatePassbook operation middleware
func (siw *ServerInterfaceWrapper) CreatePassbook(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePassbook(w, r)
	})

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/passbook", wrapper.CreatePassbook)
	})

	return r
}

type CreatePassbookRequestObject struct {
	Body *CreatePassbookJSONRequestBody
}

type CreatePassbookResponseObject interface {
	VisitCreatePassbookResponse(w http.ResponseWriter) error
}

type CreatePassbook200JSONResponse CreatePassbookResponse

func (response CreatePassbook200JSONResponse) VisitCreatePassbookResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CreatePassbook400Response struct {
}

func (response CreatePassbook400Response) VisitCreatePassbookResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreatePassbook500Response struct {
}

func (response CreatePassbook500Response) VisitCreatePassbookResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Create a iOS Wallet Pass (Passbook) and returns a link to visit and add it on your iOS device (iPhone, iPad, iWatch).
	// (POST /api/v1/passbook)
	CreatePassbook(ctx context.Context, request CreatePassbookRequestObject) (CreatePassbookResponseObject, error)
}

type StrictHandlerFunc func(ctx context.Context, w http.ResponseWriter, r *http.Request, args interface{}) (interface{}, error)

type StrictMiddlewareFunc func(f StrictHandlerFunc, operationID string) StrictHandlerFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// CreatePassbook operation middleware
func (sh *strictHandler) CreatePassbook(w http.ResponseWriter, r *http.Request) {
	var request CreatePassbookRequestObject

	var body CreatePassbookJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePassbook(ctx, request.(CreatePassbookRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePassbook")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreatePassbookResponseObject); ok {
		if err := validResponse.VisitCreatePassbookResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("Unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
